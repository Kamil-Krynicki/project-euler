package org.krynicki.euler;

import java.util.PriorityQueue;
import java.util.function.LongFunction;

/**
 * Created by kamil.krynicki on 27/10/2016.
 */
public class Problem45_TrianglePentagonHexagon {
    /*
    Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

    Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
    Pentagonal	 	Pn=n(3n−1)/2	1, 5, 12, 22, 35, ...
    Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
    It can be verified that T285 = P165 = H143 = 40755.

    Find the next triangle n that is also pentagonal and hexagonal.
    */

    public static void main(String[] args) {
        PriorityQueue<Generator> queue = new PriorityQueue<>();

        Generator g1 = new Generator(285, t -> t * (t + 1) >> 1);
        Generator g2 = new Generator(165, t -> t * (3 * t - 1) >> 1);
        Generator g3 = new Generator(143, t -> t * (2 * t - 1));

        queue.add(g1);
        queue.add(g2);
        queue.add(g3);

        long t1 = System.currentTimeMillis();

        do {
            queue.add(queue.poll().next());
        } while (g1.value() != g2.value() || g2.value() != g3.value());

        long t2 = System.currentTimeMillis();

        System.out.println(t2 - t1);
        System.out.println("Triple Number:" + g1.number());
        System.out.println("Pentagon Number:" + g2.number());
        System.out.println("Hexagon Number:" + g3.number());
        System.out.println("Value:" + g3.value());
    }

    public static class Generator implements Comparable<Generator> {
        private long val;
        private long n;
        private LongFunction<Long> genFunction;

        protected Generator(LongFunction<Long> gen) {
            this(1, gen);
        }

        protected Generator(int startFrom, LongFunction<Long> genFunction) {
            this.genFunction = genFunction;
            this.n = startFrom;
            this.val = genFunction.apply(n);
        }

        public long value() {
            return val;
        }

        public long number() {
            return n;
        }

        public Generator next() {
            n++;
            val = genFunction.apply(n);
            return this;
        }

        @Override
        public int compareTo(Generator that) {
            return (int) (this.val - that.val);
        }
    }
}
